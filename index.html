<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta property="og:image" content="https://ace-2504.github.io/api-design-blog/blogapithumbnail.png" />
  <title>How Structured Thinking Fixed My API Design</title>
    <style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    line-height: 1.5;
    color: #333;
    background: #f5f5f5;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px 15px;
    background: white;
    text-align: center;
}

h1 {
    font-size: 2.2rem;
    margin-bottom: 15px;
    color: #2c3e50;
    line-height: 1.2;
    text-align: left;
}

h2 {
    font-size: 1.6rem;
    margin-top: 25px;
    margin-bottom: 12px;
    color: #34495e;
    border-bottom: 2px solid #3498db;
    padding-bottom: 8px;
    text-align: left;
}

h3 {
    font-size: 1.2rem;
    margin-top: 15px;
    margin-bottom: 8px;
    color: #34495e;
    text-align: left;
}

p {
    margin-bottom: 10px;
    text-align: justify;
    font-size: 1rem;
    line-height: 1.5;
}

strong {
    color: #2c3e50;
}

em {
    color: #555;
    font-style: italic;
    display: inline-block;
    background: #ecf0f1;
    border-left: 3px solid #3498db;
    padding: 3px 6px;
    border-radius: 3px;
    font-size: 0.95rem;
}

.emphasis-block {
    background: #ecf0f1;
    padding: 10px;
    border-left: 3px solid #3498db;
    margin: 12px 0;
    text-align: center;
    font-size: 0.95rem;
}

code {
    background: #f4f4f4;
    padding: 1px 4px;
    border-radius: 3px;
    font-family: 'Courier New', monospace;
    color: #ffffff;
    font-size: 0.85rem;
}

img {
    display: block;
    margin: 15px auto;
    max-width: 100%;
    height: auto;
    border-radius: 6px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
}

pre {
    background: #2c3e50;
    color: #ffffff;
    padding: 12px;
    border-radius: 4px;
    overflow-x: auto;
    margin: 12px 0;
    text-align: left;
    font-size: 0.8rem;
    line-height: 1.3;
}

pre, pre code {
    text-align: left;
}

pre code {
    background: none;
    padding: 0;
    color: #ffffff;
}

table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    font-size: 0.9rem;
}

table th {
    background: #3498db;
    color: white;
    padding: 10px 8px;
    text-align: center;
    font-weight: 600;
}

table td {
    padding: 8px 10px;
    border: 1px solid #ddd;
    text-align: center;
}

table tr:nth-child(even) {
    background: #f9f9f9;
}

table tr:hover {
    background: #ecf0f1;
}

ul, ol {
    margin: 10px 0;
    text-align: left;
    padding-left: 25px;
}

li {
    margin: 4px 0;
    text-align: left;
    list-style-type: disc;
}

ol li {
    list-style-type: decimal;
}

li ul, li ol {
    margin-top: 4px;
    padding-left: 25px;
    text-align: left;
}

li ul li {
    list-style-type: circle;
}

li p {
    text-align: left;
    margin: 2px 0;
}

.author-section {
    background: #ecf0f1;
    padding: 20px;
    border-radius: 5px;
    margin-top: 25px;
    text-align: center;
}

.author-section p {
    margin: 6px 0;
}

.author-section a {
    color: #3498db;
    text-decoration: none;
}

.author-section a:hover {
    text-decoration: underline;
}

.disclaimer {
    background: #fff3cd;
    padding: 15px;
    border-radius: 5px;
    margin-top: 20px;
    font-size: 0.9rem;
    text-align: center;
    color: #856404;
}

hr {
    border: none;
    height: 2px;
    background: #3498db;
    margin: 25px 0;
}

/* Mobile Responsive Styles */
@media screen and (max-width: 768px) {
    body {
        font-size: 16px;
    }

    .container {
        padding: 15px 10px;
        max-width: 100%;
    }

    h1 {
        font-size: 1.6rem;
        margin-bottom: 12px;
    }

    h2 {
        font-size: 1.3rem;
        margin-top: 20px;
        margin-bottom: 10px;
    }

    h3 {
        font-size: 1.1rem;
        margin-top: 12px;
        margin-bottom: 6px;
    }

    p {
        font-size: 0.95rem;
        text-align: left;
    }

    /* Make flex layouts stack vertically */
    div[style*="display: flex"] {
        flex-direction: column !important;
        gap: 15px !important;
    }

    /* Adjust table for mobile */
    table {
        font-size: 0.8rem;
        display: block;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
    }

    table th, table td {
        padding: 6px 4px;
        font-size: 0.75rem;
    }

    /* Code blocks */
    pre {
        font-size: 0.7rem;
        padding: 10px;
        overflow-x: auto;
    }

    code {
        font-size: 0.75rem;
    }

    /* Images */
    img {
        margin: 10px auto;
    }

    /* Gray boxes and callouts */
    div[style*="padding: 20px"] {
        padding: 12px !important;
        margin: 15px 0 !important;
    }

    div[style*="padding: 12px"] {
        padding: 10px !important;
    }

    /* Emphasis blocks */
    .emphasis-block {
        padding: 8px;
        font-size: 0.85rem;
    }

    em {
        font-size: 0.85rem;
        padding: 2px 4px;
    }

    /* Author and disclaimer sections */
    .author-section, .disclaimer {
        padding: 12px;
        font-size: 0.85rem;
    }

    /* Lists */
    ul, ol {
        padding-left: 20px;
    }

    li {
        font-size: 0.9rem;
    }

    /* HR lines */
    hr {
        margin: 15px 0;
    }

    /* Reduce margins on styled divs */
    div[style*="margin: 20px 0"] {
        margin: 12px 0 !important;
    }

    div[style*="margin: 30px 0"] {
        margin: 15px 0 !important;
    }
}

@media screen and (max-width: 480px) {
    h1 {
        font-size: 1.4rem;
    }

    h2 {
        font-size: 1.2rem;
    }

    h3 {
        font-size: 1rem;
    }

    p {
        font-size: 0.9rem;
    }

    table {
        font-size: 0.7rem;
    }

    table th, table td {
        padding: 4px 2px;
        font-size: 0.7rem;
    }

    pre {
        font-size: 0.65rem;
        padding: 8px;
    }
}
    </style>
</head>
<body>
        <div class="container">
<h2 style="text-align: center; border-bottom: none; margin-bottom: 8px;">How Structured Thinking Transformed REST API Design</h2>
<p style="text-align: center; margin-bottom: 8px;"><strong>Harman Singh Sandhu | First-year BTech CSE at JIIT Noida | BS Data Science at IIT Madras</strong></p>
<hr style="border: none; height: 2px; background: #3498db; margin: 0 0 12px 0;">
<h3>Executive Summary</h3>
<p><strong>While building the backend for Ace Rentals, I noticed that authorization logic had slowly become scattered across many API routes.</strong> The system worked, but every protected route had its own ownership checks, which meant the same logic was being repeated again and again. As the project grew, this made the code harder to maintain and increased the risk that a route could accidentally miss an authorization check.</p>
<p>The core issue wasn’t a bug in the code—it was how authorization was structured. Access control depended on developers remembering to add checks in every route, instead of being enforced by the system itself. That approach doesn’t scale well and becomes fragile as more features and routes are added.</p>
<p>At the same time, the API was already in use, so a full rewrite wasn’t realistic. The solution needed to work within the existing Express setup, avoid breaking current behavior, and keep changes focused on improving how authorization rules were organized rather than redesigning the entire system.</p>
<p>To move forward, I stepped back and analyzed the problem before writing more code. This helped clarify that authorization is a rule that applies across many routes and features and should be handled in one shared place instead of being repeated everywhere. I compared different ways of structuring the solution and set clear goals to keep the refactor practical and contained.</p>
<p>The final decision was to centralize authorization logic into middleware. Ownership checks were removed from individual routes and enforced consistently before any business logic runs. Routes were also restructured around resources, which made the API clearer and allowed authorization rules to fit naturally into the request flow.</p>
<p>As a result, duplicated logic was eliminated, route handlers became simpler, and authorization enforcement became predictable by default. More importantly, access control shifted from something developers had to remember to something the architecture guarantees. This change made the system easier to maintain, safer to extend, and better prepared to scale.</p>

<p style="padding: 15px; background: #e8eaed; border-left: 4px solid #3498db; border-radius: 4px; margin: 15px 0;"><strong>Key takeaways:</strong> Problems that show up repeatedly in code are often design issues, not implementation mistakes. Rules like authorization that apply across many routes should be enforced in one shared place rather than copied everywhere. Good system design reduces the chance of human error and makes growth easier to manage.</p>

<hr style="border: none; height: 2px; background: #3498db; margin: 0 0 12px 0;">

<h3>Setting the Context: From Working Code to Structural Issues</h3>
<p>Before diving into the redesign, it’s important to understand how the original structure evolved and why it became a problem.
</p>
<p>While building Ace Rentals, a listings and reviews website, authorization logic evolved gradually alongside new features. As actions like deleting listings and reviews were added, it became necessary to ensure that users could only modify or remove resources they owned.
</p>
<p>What started as simple ownership checks eventually exposed deeper design concerns. This article reflects on how applying structured thinking helped me move from scattered authorization logic to a centralized, middleware-based approach, improving clarity, maintainability, and confidence in the system as it grew.</p>
<p><strong>Understanding the Problem: Scattered Authorization Logic</strong></p>
<p>In the early iterations of the Ace Rentals API, authorization checks were implemented directly within route handlers. Each route was responsible for independently verifying whether a user was authenticated and whether they owned the target resource.
</p>
<p>While this approach worked functionally, it resulted in repeated authorization logic scattered across the codebase. Any route that allowed deletion or modification had to manually include the same ownership check, increasing the risk of inconsistency and oversight as the system evolved.
</p>
<p>The turning point came when I added a new endpoint and realized — almost as an afterthought — that I needed to repeat the same ownership check yet again. For a moment, it wasn’t clear whether I had already enforced it elsewhere or had simply assumed it was covered. Nothing broke, but that uncertainty itself was the problem. The system still worked, yet it was becoming increasingly difficult to trust.</p>
<p>At this point, I had to work within a few clear constraints. The API was already functional, so the solution needed to avoid breaking existing routes or changing how clients interacted with the system. Rewriting large parts of the application or introducing additional services would have added complexity without solving the underlying problem. Given these constraints, the focus was on improving how authorization rules were structured within the existing Express setup rather than redesigning the system entirely.</p>

<p><strong>Observing the Problem in Code</strong></p>
<p>A closer examination of the code structure reveals that both deletion routes perform identical ownership verification logic: the resource is fetched, the creator’s identifier is compared against the logged-in user’s identifier, a forbidden response is returned if the check fails, and execution proceeds only if authorization succeeds.</p>
<pre style="position: relative;"><code>// Delete Listing Route
router.delete('/listings/:id', (req, res) =&gt; {
  Listing.findById(req.params.id, (err, listing) =&gt; {
    <span style="background: #fff3cd; color: #856404; padding: 2px 4px; border-radius: 3px; font-weight: 600;">// ⚠️ SECURITY CHECK - Must be manually added to every route</span>
    if (listing.creator.toString() !== req.user._id.toString()) {
      return res.status(403).send("Unauthorized");
    }
    <span style="background: #f8d7da; color: #721c24; padding: 2px 4px; border-radius: 3px; font-weight: 600;">// ⚠️ Problem: If I forget this check, users can delete ANY listing</span>
    listing.deleteOne();
    res.redirect('/listings');
  });
});

// Delete Review Route - IDENTICAL LOGIC (Copy-Pasted Security Check)
router.delete('/reviews/:id', (req, res) =&gt; {
  Review.findById(req.params.id, (err, review) =&gt; {
    <span style="background: #fff3cd; color: #856404; padding: 2px 4px; border-radius: 3px; font-weight: 600;">// ⚠️ SAME SECURITY CHECK - Duplicated code, different variable names</span>
    if (review.author.toString() !== req.user._id.toString()) {
      return res.status(403).send("Unauthorized");
    }
    <span style="background: #f8d7da; color: #721c24; padding: 2px 4px; border-radius: 3px; font-weight: 600;">// ⚠️ Problem: If I forget this check, users can delete ANY review</span>
    review.deleteOne();
    res.redirect('/');
  });
});
</code></pre>
<p>Although the routes operate on different resources, the authorization logic is effectively the same. The only variation lies in the property names (listing.creator versus review.author). This pattern led to authorization checks being duplicated across multiple routes, requiring developers to remember to re-implement the same logic each time a new endpoint was added.
</p>
<p>The risk was subtle but significant: forgetting this check even once could allow a user to delete a resource they did not own, introducing a potential security vulnerability.
</p>
<p>Another observed challenge was that someone examining the code structure might not readily discern that reviews belong to listings. That relationship existed primarily in the database schema; the API structure did not explicitly reveal it.</p>
<p><strong>Structural Limitations in the API Design</strong></p>
<p>Another limitation emerged from the API structure itself. From the routing design alone, it was not immediately clear that reviews belonged to listings. This relationship was primarily expressed at the database level rather than being reflected explicitly in the API’s URL structure, reducing the self-documenting nature of the interface.</p>
<p><strong>Identified Issues</strong></p>
<p>Based on these observations, two core issues were identified:</p>
<ul>
  <li>Duplicated authorization logic, increasing maintenance effort and the likelihood of inconsistent updates.</li>
  <li>Non-systematic authorization coverage, where security relied on manual repetition rather than structural enforcement, increasing the risk of missed checks.</li>
</ul>

<p style="font-weight: bold; font-size: 0.85em; margin: 0px">To make the scattered nature of my authorization logic more apparent, refer to the visual representation below:</p>
<div style="display: flex; gap: 30px; margin: 30px 0; margin-top: 1px;">
  <!-- LEFT COLUMN: Image + Caption -->
  <div style="flex: 0 0 55%;">
    <img src="fig1.png" alt="Figure 1" style="width:100%; height: 497.071px; border: 3px solid #3498db;" />    
  <figcaption style="text-align: left; font-style: italic; margin-top: 8px;">Figure 1: This visual represents how authorization checks were scattered across multiple routes, creating duplication and increasing the risk of inconsistent enforcement.</figcaption>

  </div>
  <!-- RIGHT COLUMN: Text Content -->
  <div style="flex: 0 0 43%; padding: 12px; background: #e8eaed; border-left: 4px solid #3498db; border-radius: 8px; height: 455px; margin-top: 15px">
    <h3 style="margin-top: 0; color: #2c3e50;">Diagnosing the Complexity of Scattered Authorization</h3>
    <p><strong>Observation (Figure 1):</strong>
      The diagram highlights a recurring pattern of scattered authorization checks, where individual routes independently implement similar ownership verification logic. This results in duplicated security checks across the codebase and reflects a lack of centralized enforcement.
</p>
    <p><strong>Impact:</strong> 
When authorization logic is duplicated, changes to security requirements must be applied in multiple places. As the number of routes grows, this increases maintenance overhead and raises the risk of inconsistent enforcement, where some endpoints may be updated while others are missed.
</p>
<p><strong>Solution Path:</strong> 
This duplication pattern indicated the need for a systematic restructuring of authorization—moving from route-by-route checks to a centralized, reusable mechanism that could be applied consistently across the entire API.
</p>
</div>
</div>
<p style="padding: 15px; background: #e8eaed; border-left: 4px solid #3498db; border-radius: 4px; margin: 15px 0;"><strong>Key Learning:</strong> Repetition in code could be a probable signal that something is structurally wrong. When one solves the same problem multiple times, it may be time to rethink the design approach.</p>

<hr style="border: none; height: 2px; background: #3498db; margin: 20px 0;">

<h3>Finding the Root Cause: Structured Problem-Solving</h3>
<p><strong>Diagnosing Structural Gaps Using MECE Analysis</strong></p>
<p>I recognized that my approach lacked consistency. Routes were being named around actions rather than organized around resources, which led to fragmented structure and repeated logic. To address this, I applied a framework I learned after graduating from the McKinsey Forward Program: MECE (Mutually Exclusive, Collectively Exhaustive) thinking.
</p>
<p>Viewed through this lens, the authorization issue became clear. The logic was not mutually exclusive, as the same ownership checks were duplicated across multiple routes. It was also not collectively exhaustive, because there was no systematic mechanism to guarantee that every route was protected.
</p>

<p>As a result, each new feature introduced unnecessary risk—every change relied on manual discipline and the assumption that no security check would be overlooked. This lack of structural enforcement made the system fragile and difficult to scale</p>
<p style="font-weight: bold; font-size: 0.85em; margin: 0px">To clarify the structural issues, the MECE analysis below visually highlights the flaws in the overall design:</p>
<div style="display: flex; gap: 30px; margin: 30px 0; margin-top: 1px;">
  <div style="flex: 0 0 55%;">
<p><img role="img" src="mece.png" style="width:100%; height: 497.071px; border: 3px solid #3498db; margin-top: 12px;" /></p>
<figcaption style="text-align: left; font-style: italic; margin-top: 8px;">Figure 2: This MECE analysis revealed that authorization logic was neither mutually exclusive nor collectively exhaustive, leading to overlap and gaps across routes.</figcaption>
  </div>
  <div style="flex: 0 0 40%; padding: 20px; background: #e8eaed; border-left: 4px solid #3498db; border-radius: 8px; height: 500px; margin-top: 12px;">
    <h3 style="margin-top: 0; color: #2c3e50;">Identifying Structural Gaps Through MECE Analysis</h3>
    <p><strong>Observation (Figure 2):</strong> 
Applying MECE analysis to the authorization logic revealed that the existing approach was neither mutually exclusive nor collectively exhaustive. Authorization checks were repeated across routes without clear boundaries, and there was no single mechanism ensuring complete coverage across all protected endpoints.
</p>   
<p><strong>Impact:</strong> 
Because authorization logic did not follow a MECE structure, the system relied on developer discipline rather than architectural guarantees. This increased the likelihood of overlap, gaps, and inconsistencies, especially as new routes were introduced or existing ones were modified.
</p>
<p><strong>Insight:</strong>
The MECE diagnosis reframed the problem from a coding issue to a structural one. It highlighted that authorization needed to be treated as a cross-cutting concern and handled centrally, rather than being embedded piecemeal within individual routes.
</p>  
  </div>
</div>

<p><strong>Evaluating Architectural Options with a Prioritization Matrix</strong></p>
<p>The MECE analysis revealed what was wrong with my approach, but I still had multiple potential solutions. I needed a structured way to choose the best long-term design. I used the Prioritization Matrix to evaluate each approach against key criteria and identify the optimal solution.</p>
<p>Each option was evaluated using two primary criteria: code reusability and long-term maintainability.</p>
<p style="font-weight: bold; font-size: 0.85em; margin: 0px">To evaluate possible solutions, I referred to the following prioritization matrix to clearly compare their respective strengths and weaknesses:</p>
<div style="display: flex; gap: 30px; align-items: flex-start; margin-top: 1px">
  <!-- LEFT COLUMN: Image + Caption -->
<div style="flex: 0 0 55%;">
<p><img role="img" src="prioritization matrix.png" style="width:100%; height: 497.071px; border: 3px solid #3498db; margin-top: 12px;" /></p>
    <figcaption style="text-align: left; font-style: italic; margin-top: 8px;">Figure 3: The prioritization matrix made the trade-offs explicit, clearly favoring centralized middleware due to superior maintainability and reusability.</figcaption>
  </div>
  <!-- RIGHT COLUMN: Text Content -->
  <div style="flex: 0 0 43%; padding: 20px; background: #e8eaed; border-left: 4px solid #3498db; border-radius: 8px; margin-top: 12px">
    <h3 style="margin-top: 0; color: #2c3e50;"> Selecting the Optimal Authorization Strategy</h3>
    <p><strong>Observation (Figure 3):</strong> 
Multiple architectural options were considered to address the authorization problem, ranging from continuing route-level checks to introducing shared helper functions or centralized middleware. The prioritization matrix evaluated these options across key dimensions such as maintainability and reusability.
</p>    
<p><strong>Impact:</strong> 
Without a structured comparison, selecting an approach would have relied on intuition rather than evidence. The matrix made the trade-offs explicit, showing that solutions which duplicated logic across routes scored poorly on both maintainability and long-term scalability.
</p>
<p><strong>Decision:</strong> 
The analysis clearly favored centralized middleware as the optimal solution. It offered high reusability, reduced duplication, and a single enforcement point, making it the most robust and maintainable approach as the API continued to grow.
</p>
  </div>
</div>

<p>Breaking down each option, the table below summarizes how each architectural approach performs across the two evaluation criteria, along with the key trade-offs involved.</p>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 13%" />
<col style="width: 16%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Architecture Approach</th>
<th style="text-align: left;">Code Reusability</th>
<th style="text-align: left;">Maintainability</th>
<th style="text-align: left;">Key Trade-offs</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Action-Based + Scattered</td>
<td style="text-align: left;">Low</td>
<td style="text-align: left;">Low</td>
<td style="text-align: left;">High burden, easy to miss, no reuse</td>
</tr>
<tr>
<td style="text-align: left;">Action-Based + Centralized</td>
<td style="text-align: left;">Low</td>
<td style="text-align: left;">High</td>
<td style="text-align: left;">Better maintenance, but verb-heavy</td>
</tr>
<tr>
<td style="text-align: left;">Resource-Based + Scattered</td>
<td style="text-align: left;">High</td>
<td style="text-align: left;">Low</td>
<td style="text-align: left;">Clean URLs, but inconsistent security</td>
</tr>
<tr>
<td style="text-align: left;">Resource-Based + Centralized</td>
<td style="text-align: left;">High</td>
<td style="text-align: left;">High</td>
<td style="text-align: left;">✅ Clean URLs, reusable, consistent</td>
</tr>
</tbody>
</table>

<p>The prioritization matrix made the path forward clear. Of the four quadrants analyzed, only resource-based routes with centralized middleware delivered both high code reusability and high maintainability. This analysis eliminated guesswork—the data pointed to one optimal solution. Now I needed to transform this strategic choice into actionable implementation steps.</p>
<br>
<p><strong>Translating Analysis into Executable Goals</strong></p>

<p>
After identifying the root cause and selecting the architectural direction, the remaining challenge was execution.
I realized that without clear boundaries, even a well-reasoned refactor could easily expand beyond its original intent.
Defining SMART goals helped me translate analysis into disciplined action and, more importantly, taught me how to
control scope during implementation.
</p>

<table border="1" cellpadding="10" cellspacing="0" style="border-collapse: collapse; width: 100%;">
  <thead>
    <tr>
      <th style="text-align: left;">SMART Criteria</th>
      <th style="text-align: left;">Implementation Target</th>
      <th style="text-align: left;">Implementation Necessity</th>
      <th style="text-align: left;">Status</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Specific</strong></td>
      <td style="text-align: left;">Centralize authorization into a single middleware</td>
      <td style="text-align: left;">A single control point was necessary to avoid relying on memory when adding or modifying routes</td>
      <td>✅</td>
    </tr>
    <tr>
      <td><strong>Measurable</strong></td>
      <td style="text-align: left;">Remove duplicated ownership checks from all protected routes</td>
      <td style="text-align: left;">Provided a concrete way to verify that the refactor actually reduced authorization risk</td>
      <td>✅</td>
    </tr>
    <tr>
      <td><strong>Achievable</strong></td>
      <td style="text-align: left;">Use existing Express middleware patterns</td>
      <td style="text-align: left;">Kept the solution practical and understandable without introducing unnecessary complexity</td>
      <td>✅</td>
    </tr>
    <tr>
      <td><strong>Relevant</strong></td>
      <td style="text-align: left;">Improve security and reduce authorization-related bugs</td>
      <td style="text-align: left;">Directly addressed the core issue identified during earlier analysis</td>
      <td>✅</td>
    </tr>
    <tr>
      <td><strong>Time-Bound</strong></td>
      <td style="text-align: left;">Complete the refactor within two weeks</td>
      <td style="text-align: left;">Prevented scope creep and enforced focused, incremental changes</td>
      <td>✅</td>
    </tr>
  </tbody>
</table>

<p>
What I learned through this step was that SMART goals are less about planning and more about restraint.
Explicitly stating why each constraint existed made it easier to stay focused during implementation and
avoid turning a targeted refactor into a broader redesign.
</p>
<!-- <p><strong style="text-align: left;">SMART Goals for Redesign</strong></p>
<p>The MECE framework had clearly diagnosed the problem—my authorization logic was scattered everywhere, creating both duplication and gaps. The prioritization matrix had identified the best path forward. Now I needed to turn this analysis into action with concrete, measurable targets.</p>
<p>The goals I set out to achieve:</p>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 64%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">SMART Criteria</th>
<th style="text-align: left;">Implementation Target</th>
<th style="text-align: left;">Status</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Specific</td>
<td style="text-align: left;">Centralize authorization into single middleware</td>
<td style="text-align: left;">✅</td>
</tr>
<tr>
<td style="text-align: left;">Measurable</td>
<td style="text-align: left;">100% code dedup, apply to all protected routes</td>
<td style="text-align: left;">✅</td>
</tr>
<tr>
<td style="text-align: left;">Achievable</td>
<td style="text-align: left;">Use Express middleware (standard), no new tech</td>
<td style="text-align: left;">✅</td>
</tr>
<tr>
<td style="text-align: left;">Relevant</td>
<td style="text-align: left;">Improve security, reduce bugs, enable scalability</td>
<td style="text-align: left;">✅</td>
</tr>
<tr>
<td style="text-align: left;">Time-Bound</td>
<td style="text-align: left;">Complete within 2 weeks</td>
<td style="text-align: left;">✅</td>
</tr>
</tbody>
</table> -->
<!-- <p>All five criteria were achieved. This framework kept me focused on
what actually mattered.</p>
<p>With SMART goals defined, the redesign followed a clear roadmap rather than ad-hoc refactoring. Centralizing authorization through middleware provided focus, measurable criteria set objective success markers, and a two-week timeline maintained execution discipline. Using standard Express middleware ensured the solution remained practical and implementable.</p> -->

<div style="padding: 20px; background: #e8eaed; border-left: 4px solid #3498db; border-radius: 8px; margin: 20px 0;">
  <p><strong>How Frameworks Work Together</strong></p>
  <p style="margin: 0;">MECE (Diagnose) → Prioritization matrix (Evaluate) → SMART (Plan) → DRY (Execute)</p>
  <p style="margin: 10px 0 0 0; font-size: 0.9rem; color: #555;">This pipeline may help transform vague problems into more systematic approaches. One possible workflow: diagnose probable issues, evaluate options, plan with measurable goals, execute with clean code principles, and work toward results that could scale.</p>
</div>

<hr style="border: none; height: 2px; background: #3498db; margin: 20px 0;">
<h3>Implementation Impact</h3>
<p>This implementation transformed authorization from a repeated, route-level responsibility into a centralized, system-level guarantee. Previously, authorization checks were embedded directly within individual route handlers, requiring manual enforcement in every endpoint. Guided by MECE analysis to identify authorization as a cross-cutting concern, validated through a prioritization matrix as the most maintainable approach, and executed using SMART goals, the refactor consolidated ownership checks into dedicated middleware applied consistently across protected Express routes. Middleware was the appropriate abstraction because authorization is orthogonal to business logic and must execute before any state-changing operation. As a result, duplicated logic was eliminated, the risk of inconsistent or missing authorization enforcement was reduced, route handlers remained focused on business logic, and the system became easier to extend, safer to modify, and more predictable as the codebase scales. This implementation also reinforced the importance of addressing structural problems before writing code, demonstrating how upfront architectural decisions can reduce long-term complexity more effectively than incremental fixes.</p>
<p><strong>The Redesign: Action-Based to Resource-Based</strong></p>
<p>The restructured approach allows HTTP methods to carry the action while URLs carry the resource. On perusal of the table below, one can observe how this structure potentially makes the API more predictable and self-documenting.</p>

<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 25%" />
<col style="width: 31%" />
<col style="width: 27%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Operation</th>
<th style="text-align: left;">Before (Action-Oriented Endpoints)</th>
<th style="text-align: left;">After (RESTful Resources)</th>
<th style="text-align: left;">Why This Matters</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Create listing</td>
<td style="text-align: left;">POST /create-listing</td>
<td style="text-align: left;">POST /listings</td>
<td style="text-align: left;">HTTP method implies action</td>
</tr>
<tr>
<td style="text-align: left;">View listing</td>
<td style="text-align: left;">GET /get-listing/:id</td>
<td style="text-align: left;">GET /listings/:id</td>
<td style="text-align: left;">Cleaner, standard</td>
</tr>
<tr>
<td style="text-align: left;">Update</td>
<td style="text-align: left;">PUT /update-listing/:id</td>
<td style="text-align: left;">PUT /listings/:id</td>
<td style="text-align: left;">Resource-scoped</td>
</tr>
<tr>
<td style="text-align: left;">Delete listing</td>
<td style="text-align: left;">DELETE /delete-listing/:id</td>
<td style="text-align: left;">DELETE /listings/:id</td>
<td style="text-align: left;">Consistent</td>
</tr>
<tr>
<td style="text-align: left;">Create review</td>
<td style="text-align: left;">POST /create-review</td>
<td style="text-align: left;">POST /listings/:id/reviews</td>
<td style="text-align: left;">Shows ownership</td>
</tr>
<tr>
<td style="text-align: left;">Delete review</td>
<td style="text-align: left;">DELETE /delete-review/:id</td>
<td style="text-align: left;">DELETE /listings/:id/reviews/:rid</td>
<td style="text-align: left;">Clear hierarchy</td>
</tr>
</tbody>
</table>
<p style="font-weight: bold; font-size: 0.85em; margin: 0px">The diagram below illustrates the transition from route-level authorization checks to a centralized middleware approach:</p>
<div style="display: flex; gap: 30px; margin: 30px 0; margin-top: 1px">
  <!-- LEFT COLUMN: Image + Caption -->
  <div style="flex: 0 0 55%;">
<p><img role="img" src="fig4.png" style="width:100%; border: 3px solid #3498db; margin-top: 12px;" /></p>
<figcaption style="text-align: left; font-style: italic; margin-top: 8px;">Figure 4: This diagram illustrates the transition from route-level authorization checks to centralized enforcement through middleware.</figcaption>
  </div>
  <!-- RIGHT COLUMN: Text Content -->
  <div style="flex: 0 0 43%; padding: 20px; background: #e8eaed; border-left: 4px solid #3498db; border-radius: 8px; margin-top: 12px; height: 430px">
    <h3 style="margin-top: 0; color: #2c3e50;">Centralizing Authorization Through Middleware</h3>
    <p><strong>Observation (Figure 4):</strong>
      The implementation moved authorization logic out of individual route handlers and into dedicated middleware that executes early in the request lifecycle. This ensured that ownership validation occurs before any business logic or state-changing operation is performed.
    </p>
      <p><strong>Impact:</strong> 
        By centralizing authorization, duplicated checks across routes were eliminated and enforcement became consistent by default. Route handlers were simplified and focused solely on domain behavior, reducing cognitive load and making the codebase easier to maintain and extend
        </p>
    <p><strong>Outcome:</strong>
      This architectural shift transformed authorization into a system-level guarantee. New routes automatically inherit authorization rules, reducing the risk of security regressions as features are added and the application scales.
      </p>
  </div>
</div>



<p><strong>Building the Solution: Centralized Authorization</strong></p>
<p>Instead of writing the ownership check in every route, I created one reusable middleware function. This function encapsulates all the authorization logic in a single place. It uses Express's middleware pattern where <strong>next()</strong> passes control to the next handler only if authorization succeeds:</p>
<pre><code>const isOwner = async (req, res, next) =&gt; {
  const listing = await Listing.findById(req.params.id);
  if (!listing.author.equals(req.user._id)) {
    req.flash('error', 'You cannot modify this listing');
    return res.redirect('/listings');
  }
  next();
};
</code></pre>
<p>This middleware is intentionally single-purpose: it verifies whether the current user owns the listing. The <strong>listing.author.equals()</strong> method safely compares MongoDB ObjectIds to avoid false matches. If the check fails, an error is flashed and the request is stopped before any data is modified. If it passes, <strong>next()</strong> forwards the request to the route handler.</p>
<p>Then I applied this single middleware to all protected routes, chaining it with authentication:</p>
<pre><code>router.put('/:id', isLoggedIn, isOwner, updateListing);
router.delete('/:id', isLoggedIn, isOwner, deleteListing);
router.delete('/:id/reviews/:rid', isLoggedIn, isOwner, deleteReview);
</code></pre>
<p>Read these routes from left to right—they form a pipeline. First <strong>isLoggedIn</strong> verifies the user has a valid session, then <strong>isOwner</strong> verifies ownership, and finally the business logic executes. The transformation is profound: the authorization check exists in exactly one place. If I need to add logging, change the error message, or modify the authorization logic, I change it once and it applies everywhere. New features automatically inherit the same security pattern—no chance of forgetting.</p>
<br>
<p>While the middleware code itself is straightforward, understanding how requests flow through this pipeline reveals the true power of this architectural pattern. The sequential execution of authentication, authorization, and business logic creates a clear separation of concerns that makes the system both more secure and more maintainable.</p>

<p style="font-weight: bold; font-size: 0.85em; margin: 0px">The following visual summarizes the measurable improvements in consistency, maintainability, and scalability after implementing centralized authorization:</p>
<div style="display: flex; gap: 30px; margin: 1px 0; align-items: flex-start;">
  <div style="flex: 0 0 55%; height: 713px; padding: 20px; margin-top: 0;">
    <figure style="margin: 0;">
      <img src="fig5.png" alt="Figure 5" style="width:100%; object-fit: cover; border: 3px solid #3498db; margin-top: 0;" />
      <figcaption style="text-align: left; font-style: italic; margin-top: 8px; padding-bottom: 32px; clear: both; display: block;">Figure 5: This visual summarizes the measurable improvement in consistency, maintainability, and scalability after centralizing authorization.</figcaption>
    </figure>
  </div>
  <div style="flex: 0 0 43%; padding: 20px; background: #e8eaed; border-left: 4px solid #3498db; border-radius: 8px; margin-top: 18px;">
    <h3 style="margin-top: 0; color: #2c3e50;">Demonstrating the Impact of the Architectural Change</h3>
    <p><strong>Observation (Figure 5):</strong> 
      After centralizing authorization, the system exhibited clearer separation of concerns and more predictable behavior across protected routes. Authorization enforcement became uniform, independent of the number of endpoints or features added.
</p>
    <p><strong>Impact:</strong> 
The refactor reduced code duplication, lowered maintenance overhead, and minimized the risk of inconsistent security enforcement. Changes to authorization rules now require updates in a single location, improving reliability and reducing the likelihood of regression.
</p>
    <p><strong>Result:</strong> 
By transforming authorization into an architectural control rather than a repeated implementation detail, the system became easier to reason about, safer to evolve, and better positioned to scale without increasing complexity.
</p>

    <p><strong>Impact:</strong> Authorization moves from repeated checks inside handlers to one reusable middleware. Route handlers shrink to just a few lines and focus only on business logic. Security becomes consistent, scalable, and impossible to forget.</p>
  </div>
</div>
<div style="padding: 20px; margin-top: 270px;">
<p><strong>Measuring the Impact of the Transformation</strong></p>
<p>The middleware pattern sounds elegant in theory, but what concrete improvements does it deliver in practice? Moving from scattered authorization checks to centralized middleware led to clear, observable changes across the codebase—from how many places required review to how confident it felt to add new features. The table below summarizes what shifted and why it mattered.</p>

<table style="width:100%;">
<colgroup>
<col style="width: 21%" />
<col style="width: 44%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Design Aspect</th>
<th style="text-align: left;">Before Refactoring</th>
<th style="text-align: left;">After Refactoring</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Route naming</td>
<td style="text-align: left;">Verb-heavy URLs</td>
<td style="text-align: left;">Resource-based URLs</td>
</tr>
<tr>
<td style="text-align: left;">Authorization</td>
<td style="text-align: left;">Repeated everywhere</td>
<td style="text-align: left;">Centralized middleware</td>
</tr>
<tr>
<td style="text-align: left;">Relationships</td>
<td style="text-align: left;">Hidden in database</td>
<td style="text-align: left;">Explicit in structure</td>
</tr>
<tr>
<td style="text-align: left;">New features</td>
<td style="text-align: left;">Manual security check each time</td>
<td style="text-align: left;">Automatic inheritance</td>
</tr>
<tr>
<td style="text-align: left;">Consistency</td>
<td style="text-align: left;">Easy to miss</td>
<td style="text-align: left;">Enforced by design</td>
</tr>
<tr>
<td style="text-align: left;">Maintenance</td>
<td style="text-align: left;">Update many files</td>
<td style="text-align: left;">Update once</td>
</tr>
</tbody>
</table>

<div style="padding: 20px; background: #e8eaed; border-left: 4px solid #3498db; border-radius: 8px;">
    <p><strong>Key Transformation:</strong> Authorization was moved out of individual route handlers and into a single middleware. This eliminated repeated security checks and ensured that every protected route is evaluated consistently. In parallel, the API was restructured so that URL paths clearly express how resources relate to one another, rather than relying on implicit database relationships. Together, these changes show how structured thinking was translated into a concrete, enforceable design in code.</p>
</div>

<hr style="border: none; height: 2px; background: #3498db; margin: 20px 0;">

<p><strong>Reflecting on the Journey</strong></p>

<p>
    This refactor wasn’t triggered by a bug or a performance issue. It came from a growing feeling that the system was becoming harder to work with as it changed. When authorization logic was repeated across multiple routes, I had to rely on memory to ensure correctness, which made the design feel fragile over time.
</p>

<p>Moving authorization into a centralized middleware didn’t just reduce duplication—it made the rules of the system easier to see and reason about. Once those rules lived in a single place, adding or modifying features felt more predictable and less error-prone.
</p>
<p>As a student, the main lesson for me is that design problems often appear before anything actually breaks. Repeated logic, uncertainty, and small moments of hesitation can signal deeper structural issues. Learning to notice and act on these signals early has been an important step in how I now think about backend design.</p>



<div style="padding: 20px; background: #e8eaed; border-left: 4px solid #3498db; border-radius: 8px; margin: 30px 0;">
  <p><strong>Key Learnings from Applying Structured Thinking</strong></p>
  <ul style="line-height: 1.8;">
    <li><strong>Resource-based design over action-based:</strong> Organizing around resources (DELETE /books/:id) creates more predictable, RESTful interfaces than action-based routes (/deleteBook).</li>
    <li><strong>Structured frameworks drive better planning:</strong> Using MECE, Prioritization Matrix, and SMART before coding helps identify problems early and avoid reactive fixes.</li>
    <li><strong>Centralize cross-cutting concerns:</strong> Middleware patterns for security, logging, and validation ensure consistency and reduce duplication across routes.</li>
    <li><strong>Make security structural, not optional:</strong> Building authorization into the architecture (middleware pipelines) is more reliable than depending on developer memory.</li>
    <li><strong>Visible relationships improve understanding:</strong> Nested routes like /listings/:id/reviews make domain relationships explicit and self-documenting.</li>
  </ul>
</div>

</div>


<div style="padding: 20px; background: #fff3cd; border-radius: 8px; margin: 20px 0; color: #000000;">
<p><strong style="color: #000000;">About the Author</strong></p>
<p style="color: #000000;">
Harman Singh Sandhu is a first-year student pursuing a BTech in Computer Science at JIIT Noida alongside a BS in Data Science at IIT Madras. An alumnus of the McKinsey Forward Program, his learning approach emphasizes structured thinking, strong engineering fundamentals, and data-driven problem-solving.
As a student developer, his interests center on understanding systems end-to-end, building practical product-oriented applications, and learning through real-world projects. He is particularly interested in open-source contribution, collaborative development, and writing clean, maintainable code that scales beyond academic settings.
</p>
<ul style="color: #000000;">
<li><p style="color: #000000;">LinkedIn: <a href="https://www.linkedin.com/in/harman-sandhu-713852367" style="color: #3498db;">https://www.linkedin.com/in/harman-sandhu-713852367</a></p></li>
<li><p style="color: #000000;">Email: <a href="mailto:harman2504sandhu@gmail.com" style="color: #3498db;">harman2504sandhu@gmail.com</a></p></li>
<li><p style="color: #000000;">Project: Ace Rentals (GitHub: <a href="https://github.com/Ace-2504/Ace-Rentals" style="color: #3498db;">https://github.com/Ace-2504/Ace-Rentals</a>)</p></li>
</ul>
</div>
<div style="padding: 20px; background: #fff3cd; border-radius: 8px; margin: 20px 0; color: #000000;">
<p><strong style="color: #000000;">Disclaimer</strong></p>
<p style="color: #000000;">

This article was developed with AI assistance strictly for language refinement, structural organization, and visual presentation. All technical concepts, problem definitions, implementation choices, architectural decisions, and trade-off analyses are based on the author’s own learning and hands-on development experience while building Ace Rentals.
</p>

</div>

        </div>
</body>
</html>
